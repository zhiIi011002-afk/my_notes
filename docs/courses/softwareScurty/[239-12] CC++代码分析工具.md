# 239-12flawfinder

## 题目:![image-20251222101142670](/course/softwareSecurtyHomework/image-20251222101142670.png)

## flawfinder的安装

先安装python3.x以上的版本，而后使用pip安装

![image-20251222103906705](/course/softwareSecurtyHomework/image-20251222103906705.png)

## flawfinder对tinytetris源码的检测

[GitHub - taylorconor/tinytetris: 80x23 terminal tetris!](https://github.com/taylorconor/tinytetris)

tinytetris是一个用C++编写的小体量终端版俄罗斯方块游戏，提供了两个版本的源码，分为注释版和库版。以下展示的是注释版。

```c++
#include <ctime>
#include <curses.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

// block layout is: {w-1,h-1}{x0,y0}{x1,y1}{x2,y2}{x3,y3} (two bits each)
int x = 431424, y = 598356, r = 427089, px = 247872, py = 799248, pr,
    c = 348480, p = 615696, tick, board[20][10],
    block[7][4] = {{x, y, x, y},
                   {r, p, r, p},
                   {c, c, c, c},
                   {599636, 431376, 598336, 432192},
                   {411985, 610832, 415808, 595540},
                   {px, py, px, py},
                   {614928, 399424, 615744, 428369}},
    score = 0;

// extract a 2-bit number from a block entry
int NUM(int x, int y) { return 3 & block[p][x] >> y; }

// create a new piece, don't remove old one (it has landed and should stick)
void new_piece() {
  y = py = 0;
  p = rand() % 7;
  r = pr = rand() % 4;
  x = px = rand() % (10 - NUM(r, 16));
}

// draw the board and score
void frame() {
  for (int i = 0; i < 20; i++) {
    move(1 + i, 1); // otherwise the box won't draw
    for (int j = 0; j < 10; j++) {
      board[i][j] && attron(262176 | board[i][j] << 8);
      printw("  ");
      attroff(262176 | board[i][j] << 8);
    }
  }
  move(21, 1);
  printw("Score: %d", score);
  refresh();
}

// set the value fo the board for a particular (x,y,r) piece
void set_piece(int x, int y, int r, int v) {
  for (int i = 0; i < 8; i += 2) {
    board[NUM(r, i * 2) + y][NUM(r, (i * 2) + 2) + x] = v;
  }
}

// move a piece from old (p*) coords to new
int update_piece() {
  set_piece(px, py, pr, 0);
  set_piece(px = x, py = y, pr = r, p + 1);
}

// remove line(s) from the board if they're full
void remove_line() {
  for (int row = y; row <= y + NUM(r, 18); row++) {
    c = 1;
    for (int i = 0; i < 10; i++) {
      c *= board[row][i];
    }
    if (!c) {
      continue;
    }
    for (int i = row - 1; i > 0; i--) {
      memcpy(&board[i + 1][0], &board[i][0], 40);
    }
    memset(&board[0][0], 0, 10);
    score++;
  }
}

// check if placing p at (x,y,r) will be a collision
int check_hit(int x, int y, int r) {
  if (y + NUM(r, 18) > 19) {
    return 1;
  }
  set_piece(px, py, pr, 0);
  c = 0;
  for (int i = 0; i < 8; i += 2) {
    board[y + NUM(r, i * 2)][x + NUM(r, (i * 2) + 2)] && c++;
  }
  set_piece(px, py, pr, p + 1);
  return c;
}

// slowly tick the piece y position down so the piece falls
int do_tick() {
  if (++tick > 30) {
    tick = 0;
    if (check_hit(x, y + 1, r)) {
      if (!y) {
        return 0;
      }
      remove_line();
      new_piece();
    } else {
      y++;
      update_piece();
    }
  }
  return 1;
}

// main game loop with wasd input checking
void runloop() {
  while (do_tick()) {
    usleep(10000);
    if ((c = getch()) == 'a' && x > 0 && !check_hit(x - 1, y, r)) {
      x--;
    }
    if (c == 'd' && x + NUM(r, 16) < 9 && !check_hit(x + 1, y, r)) {
      x++;
    }
    if (c == 's') {
      while (!check_hit(x, y + 1, r)) {
        y++;
        update_piece();
      }
      remove_line();
      new_piece();
    }
    if (c == 'w') {
      ++r %= 4;
      while (x + NUM(r, 16) > 9) {
        x--;
      }
      if (check_hit(x, y, r)) {
        x = px;
        r = pr;
      }
    }
    if (c == 'q') {
      return;
    }
    update_piece();
    frame();
  }
}

// init curses and start runloop
int main() {
  srand(time(0));
  initscr();
  start_color();
  // colours indexed by their position in the block
  for (int i = 1; i < 8; i++) {
    init_pair(i, i, 0);
  }
  new_piece();
  resizeterm(22, 22);
  noecho();
  timeout(0);
  curs_set(0);
  box(stdscr, 0, 0);
  runloop();
  endwin();
}
```

将其检测结果输入到html文件中：

![image-20251222105422356](/course/softwareSecurtyHomework/image-20251222105422356.png)

**涉及到的漏洞：**

1. **srand函数的随机性不足（CWE-327）**：
   - 使用`srand`函数来初始化随机数生成器。这个函数的随机性不足以用于安全相关的功能，比如密钥和一次性数字的生成。建议使用更安全的随机值获取技术，比如C++11中的`<random>`库。
2. **memcpy函数的缓冲区溢出（CWE-120）**：
   - 使用`memcpy`函数复制数据时没有检查目标缓冲区是否溢出。这意味着如果源数据大于目标缓冲区的大小，可能会导致缓冲区溢出，这是一个常见的安全漏洞。建议确保目标缓冲区总是能够容纳源数据。
3. **usleep函数的过时性（CWE-676）**：
   - 使用了`usleep`函数来暂停程序执行。这个函数被认为是过时的，并且其与`SIGALRM`信号和其他计时函数（如`sleep()`、`alarm()`、`setitimer()`和`nanosleep()`）的交互是未定义的。建议使用`nanosleep(2)`或`setitimer(2)`代替。



## flawfinder与其他代码分析工具的比较

类似Flawfinder的工具有很多，它们都是用于静态代码分析的工具，可以帮助开发者在代码执行前发现错误、漏洞、风格和结构问题。以下是一些类似Flawfinder的工具，以及它们的比较：

1. **Cppcheck**：
   - 支持C和C++代码的静态分析。
   - 能够检测除编译器会检测到的错误外的其他类型错误，假阳性率较低。
   - 容易安装和使用，支持所有平台。
   - 专注于检测越界错误、内存泄露、语法错误等问题。
   - 对新手友好，提供详细的报告帮助开发者定位问题。
   - 检测能力较强，友好度和易用性均较高。
2. **Clang Static Analyzer**：
   - 基于LLVM的工具，用于C、C++和Objective-C代码的静态分析。
   - 可以集成到编译过程中，或作为独立工具运行。
   - 能检测空指针解引用、内存泄露、逻辑错误等问题。
   - 输出报告直观且便于理解。
3. **Splint**：
   - 一个针对C语言的静态分析工具。
   - 以注释为依据进行分析，可以检测出多种编程错误。
   - 对于代码风格和潜在的运行时错误有较好的检测能力。
4. **TscanCode**：
   - 支持C、C++、C#和Lua代码的静态分析。
   - 提供开源版本，支持Windows、Linux和Mac OS平台。
   - 提示信息与Cppcheck相似，但给出的提示数量较少。

- **检测能力**：Cppcheck > TscanCode > Flawfinder
- **友好度**：TscanCode > Cppcheck > Flawfinder
- **易用性**：TscanCode > Cppcheck > Flawfinder

即 在检测能力、友好度和易用性上，flawfinder仍有改进的空间。且其仅仅支持c/c++的代码检测，语言的种类多样性上仍有提升空间。







