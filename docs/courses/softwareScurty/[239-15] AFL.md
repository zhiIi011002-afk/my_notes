# 239-15 AFL漏洞挖掘：

![title](/course/softwareSecurtyHomework/title.png)

## AFL下载

在microsoft store上，用WSL Ubuntu上下载AFL。

有个坑：不要直接下载Ubuntu,应该下载它的LTS版本。（直接下载后，连make命令都用不了）

![image](/course/softwareSecurtyHomework/image.png)

下载AFL:

```bash
wget https://lcamtuf.coredump.cx/afl/releases/afl-latest.tgz
```

## 测试代码

在ubuntu系统中用nano创建测试代码：

参考：[我的AFL入门之路 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/524552737)

1. ```c
   #include <stdio.h>
   #include <stdlib.h>
   #include <unistd.h>
   #include <string.h>
   #include <signal.h>
   
   int vuln(char *str) {
       int len = strlen(str);
       if (str[0] == 'A' && len == 66) {
           // 如果输入的字符串的首字符为A并且长度为66，则异常退出
           raise(SIGSEGV);
       } else if (str[0] == 'F' && len == 6) {
           // 如果输入的字符串的首字符为F并且长度为6，则异常退出
           raise(SIGSEGV);
       } else {
           printf("it is good!\n");
       }
       return 0;
   }
   
   int main(int argc, char *argv[]) {
       char buf[100] = {0};
       gets(buf);  // 存在栈溢出漏洞。如果输入过长，则会导致栈溢出
       printf(buf);  // 存在格式化字符串漏洞.没有指定格式字符串，如果buf包含格式化指令,则会导致未定义行为
       vuln(buf);
       return 0;
   }
   ```

**流程概述：**

1. 首先是用afl-gcc编译源代码，以此测试文件为输入.
2. 然后启动afl-fuzz程序，将testcase(输入的测试文件)作为程序的输入执行程序，afl会在这个testcase的基础上进行自动变异输入，使得程序产生crash，产生了crash就会被记录起来。

### 1. 编译与模糊测试

对test.c进行编译。（如果是编译一个c的源码，那就需要用afl-g）

```bash
 afl-gcc -g -o ./afl_example ./test.c
```

```bash
#进行模糊测试
afl-fuzz -i fuzz_in -o fuzz_out ./afl_example -f
```

运行这段时间后 产生了5个crashes：

![image-20251222115057111](/course/softwareSecurtyHomework/image-20251222115057111.png)

用XXD工具分析：
![image-20251222115430164](/course/softwareSecurtyHomework/image-20251222115430164.png)

000000：

这种情况符合我们在vuln中规定的：如果输入的字符串的首字符为F并且长度为6，则异常退出。

000001：

这种情况的输入数据长度为9*16+3=147字节，超出了buf的长度从而导致了栈溢出错误。

000002：

这种情况的输入中包含%S这一printf输入控制符，导致了printf的错误，存在格式化字符串漏洞。

000003：

这种情况的输入数据长度为7*16=112字节，超出了buf的长度从而导致了栈溢出错误。

000004：

这种情况符合我们在vuln中规定的：如果输入的字符串的首字符为A并且长度为66，则异常退出。

**AFL的模糊测试基本找出了我们给定代码中的一些漏洞。**